package com.assessmentprod.userServiceV1;


import com.assessmentprod.userServiceV1.dto.UserInfoRes;
import com.assessmentprod.userServiceV1.entity.UserData;
import com.assessmentprod.userServiceV1.entity.role;
import com.assessmentprod.userServiceV1.exception.UserNotFoundException;
import com.assessmentprod.userServiceV1.repository.UserDataRepository;
import com.assessmentprod.userServiceV1.service.AdminService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.when;

public class AdminServiceTest {

    @Mock
    private UserDataRepository userDataRepository;

    @InjectMocks
    private AdminService adminService;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void getAllUsers_ShouldReturnListOfNonAdminUsers() {
        // Arrange
        List<UserData> mockUsers = List.of(
                new UserData(1L, "User1", "user1@example.com", role.USER),
                new UserData(2L, "User2", "user2@example.com", role.USER)
        );
        when(userDataRepository.findByRoleNot(role.ADMIN)).thenReturn(mockUsers);

        // Act
        List<UserInfoRes> result = adminService.getAllUsers();

        // Assert
        assertEquals(2, result.size());
        assertTrue(result.stream().allMatch(user -> user.role() != role.ADMIN));
    }

    @Test
    public void getUser_WhenUserExists_ShouldReturnUserInfo() {
        UserData mockUser = new UserData(1L, "User1", "user1@example.com", role.USER);
        when(userDataRepository.findById(1L)).thenReturn(Optional.of(mockUser));

        UserInfoRes result = adminService.getUser(1L);

        assertAll("User Info",
                () -> assertEquals("User1", result.username(), "Username should match"),
                () -> assertEquals("user1@example.com", result.email(), "Email should match"),
                () -> assertEquals(role.USER, result.role(), "Role should match")
        );
    }



    @Test
    public void getUser_WhenUserDoesNotExist_ShouldThrowUserNotFoundException() {
        // Arrange
        when(userDataRepository.findById(99L)).thenReturn(Optional.empty());

        // Act & Assert
        assertThrows(UserNotFoundException.class, () -> adminService.getUser(99L));
    }

    @Test
    public void updateUserRole_WhenUserExists_ShouldUpdateUserRole() {
        // Arrange
        UserData mockUser = new UserData(1L, "User1", "user1@example.com", role.USER);
        UserData updatedUser = new UserData(1L, "User1", "user1@example.com", role.ADMIN);

        when(userDataRepository.findById(1L)).thenReturn(Optional.of(mockUser));
        when(userDataRepository.save(any(UserData.class))).thenReturn(updatedUser);

        // Act
        UserInfoRes result = adminService.updateUserRole(1L, role.ADMIN);

        // Assert
        assertEquals(role.ADMIN, result.role(), "The role should be updated to ADMIN");
    }


    @Test
    public void updateUserrole_WhenUserDoesNotExist_ShouldThrowUserNotFoundException() {
        // Arrange
        when(userDataRepository.findById(99L)).thenReturn(Optional.empty());

        // Act & Assert
        assertThrows(UserNotFoundException.class, () -> adminService.updateUserRole(99L, role.ADMIN));
    }
}
